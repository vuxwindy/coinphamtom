import{e as p}from"./utils-GbVwyc3t.js";import{concatHex as v}from"./concat-hex-C8eryf6L.js";import{readContract as x}from"./read-contract-DpACvx2n.js";import{bt as f,bu as D,at as c,bv as m,bw as M,bx as I,by as C,bz as V,ab as g,ah as h,ao as l}from"./index-r-K8bCt4.js";import{p as w}from"./index-V_i5jKWp.js";import"./to-serializable-transaction-BMbNRj8d.js";import"./bundler-DmxEBivy.js";import"./addresses-Cbjra2SQ.js";import"./send-eip712-transaction-FYI7wW-w.js";import"./eth_sendRawTransaction-DPdnXbFR.js";import"./random-Dc3txyW0.js";import"./send-transaction-DRs_bS9h.js";const P="0x1626ba7e",_=[{name:"hash",type:"bytes32"},{name:"signature",type:"bytes"}],H=[{type:"bytes4"}];async function $(t){return x({contract:t.contract,method:[P,_,H],params:[t.hash,t.signature]})}const F="0x6492649264926492649264926492649264926492649264926492649264926492";function A({address:t,data:r,signature:e}){return v([p([{type:"address"},{type:"bytes"},{type:"bytes"}],[t,r,e]),F])}const O="0x1626ba7e";async function b({hash:t,signature:r,contract:e}){try{return await $({contract:e,hash:t,signature:r})===O}catch(n){return console.error("Error verifying EIP-1271 signature",n),!1}}const U=`Ethereum Signed Message:
`;function L(t,r){const e=typeof t=="string"?f(t):t.raw instanceof Uint8Array?t.raw:D(t.raw),n=f(`${U}${e.length}`);return c(m(n,e),r)}function B(t){const{domain:r={},message:e,primaryType:n}=t,a={EIP712Domain:M(r),...t.types};I({domain:r,message:e,primaryType:n,types:a});const s=["0x1901"];if(r&&s.push(C({domain:r,types:a})),n!=="EIP712Domain"){const i=(()=>{const o=T({data:e,primaryType:n,types:a});return c(o)})();s.push(i)}return c(m(...s.map(i=>V(i))))}function T({data:t,primaryType:r,types:e}){const n=[{type:"bytes32"}],a=[N({primaryType:r,types:e})];if(!e[r])throw new Error("Invalid types");for(const s of e[r]){const[i,o]=E({name:s.name,type:s.type,types:e,value:t[s.name]});n.push(i),a.push(o)}return p(n,a)}function N({primaryType:t,types:r}){const e=g(k({primaryType:t,types:r}));return c(e)}function k({primaryType:t,types:r}){let e="";const n=S({primaryType:t,types:r});n.delete(t);const a=[t,...Array.from(n).sort()];for(const s of a){if(!r[s])throw new Error("Invalid types");e+=`${s}(${r[s].map(({name:i,type:o})=>`${o} ${i}`).join(",")})`}return e}function S({primaryType:t,types:r},e=new Set){const a=t.match(/^\w*/u)?.[0];if(e.has(a)||r[a]===void 0)return e;e.add(a);for(const s of r[a])S({primaryType:s.type,types:r},e);return e}function E({types:t,name:r,type:e,value:n}){if(t[e]!==void 0)return[{type:"bytes32"},c(T({data:n,primaryType:e,types:t}))];if(e==="bytes")return n=`0x${(n.length%2?"0":"")+n.slice(2)}`,[{type:"bytes32"},c(n)];if(e==="string")return[{type:"bytes32"},c(g(n))];if(e.lastIndexOf("]")===e.length-1){const a=e.slice(0,e.lastIndexOf("[")),s=n.map(i=>E({name:r,type:a,types:t,value:i}));return[{type:"bytes32"},c(p(s.map(([i])=>i),s.map(([,i])=>i)))]}return[{type:e},n]}async function te({accountContract:t,factoryContract:r,options:e,message:n}){const a=L(n);let s;const i=p([{type:"bytes32"}],[a]);if(s=await e.personalAccount.signTypedData({domain:{chainId:e.chain.id,name:"Account",verifyingContract:t.address,version:"1"},message:{message:i},primaryType:"AccountMessage",types:{AccountMessage:[{name:"message",type:"bytes"}]}}),await h(t)){if(await b({contract:t,hash:a,signature:s}))return s;throw new Error("Failed to verify signature")}else{const u=w({accountSalt:e.overrides?.accountSalt,adminAddress:e.personalAccount.address,createAccountOverride:e.overrides?.createAccount,factoryContract:r});if(!u)throw new Error("Create account override not provided");const d=await l(u);return A({address:r.address,data:d,signature:s})}}async function re({accountContract:t,factoryContract:r,options:e,typedData:n}){if(n.domain?.verifyingContract?.toLowerCase()===t.address?.toLowerCase())return e.personalAccount.signTypedData(n);const s=B(n);let i;const o=p([{type:"bytes32"}],[s]);if(i=await e.personalAccount.signTypedData({domain:{chainId:e.chain.id,name:"Account",verifyingContract:t.address,version:"1"},message:{message:o},primaryType:"AccountMessage",types:{AccountMessage:[{name:"message",type:"bytes"}]}}),await h(t)){if(await b({contract:t,hash:s,signature:i}))return i;throw new Error("Failed to verify signature")}else{const d=w({accountSalt:e.overrides?.accountSalt,adminAddress:e.personalAccount.address,createAccountOverride:e.overrides?.createAccount,factoryContract:r});if(!d)throw new Error("Create account override not provided");const y=await l(d);return A({address:r.address,data:y,signature:i})}}export{te as smartAccountSignMessage,re as smartAccountSignTypedData};
