const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/decimals-BQ2RiGna.js","assets/index-r-K8bCt4.js","assets/index-BwMRwPhq.css","assets/read-contract-DpACvx2n.js","assets/utils-GbVwyc3t.js","assets/to-serializable-transaction-BMbNRj8d.js","assets/signing-BGN0s6tt.js","assets/concat-hex-C8eryf6L.js","assets/bundler-DmxEBivy.js","assets/addresses-Cbjra2SQ.js","assets/send-eip712-transaction-FYI7wW-w.js","assets/eth_sendRawTransaction-DPdnXbFR.js","assets/random-Dc3txyW0.js","assets/send-transaction-DRs_bS9h.js","assets/in-app-wallet-calls-DoVweYsf.js","assets/wait-for-tx-receipt-C9zxAqk4.js","assets/sleep-mAKpSMLY.js"])))=>i.map(i=>d[i]);
import{ag as me,ac as W,Z as z,O as x,ah as K,ai as D,aj as C,ak as j,al as S,a7 as ue,K as Z,am as _,an as k,ao as H,ap as O,aq as pe,ar as ye,as as T,at as le,ab as fe,au as we,av as Y,aw as J,ax as Ae,ay as ve,S as Q,U as he,N as b,a1 as I,az as ge,aA as Ge}from"./index-r-K8bCt4.js";import{readContract as L}from"./read-contract-DpACvx2n.js";import{t as Te,a as X,c as F,g as Pe,b as xe}from"./to-serializable-transaction-BMbNRj8d.js";import{p as E,o as ee,h as Le,g as Oe,a as De,b as Ce,e as V,c as Se,d as _e,f as Fe}from"./bundler-DmxEBivy.js";import{Z as te}from"./addresses-Cbjra2SQ.js";import{t as Ee,p as be,s as Ie}from"./send-eip712-transaction-FYI7wW-w.js";import{r as Ve}from"./random-Dc3txyW0.js";import{s as Ue}from"./send-transaction-DRs_bS9h.js";import{e as Ne}from"./utils-GbVwyc3t.js";async function $e(e){const{factoryContract:a,predictAddressOverride:t,adminAddress:r,accountSalt:n,accountAddress:s}=e;if(t)return t(a,r);if(s)return s;if(!r)throw new Error("Account address is required to predict the smart wallet address.");return me(async()=>{const c=n&&W(n)?n:z(n??"");let i,m=0;const u=3;for(;m<=u;)try{i=await L({contract:a,method:"function getAddress(address, bytes) returns (address)",params:[r,c]});break}catch(y){if(m===u)throw y;const l=2**(m+1)*200;await new Promise(o=>setTimeout(o,l)),m++}if(!i)throw new Error(`No smart account address found for admin address ${r} and salt ${n}`);return i},{cacheKey:`${e.factoryContract.chain.id}-${e.factoryContract.address}-${e.adminAddress}-${e.accountSalt}`,cacheTime:1e3*60*60*24})}function ae(e){const{adminAddress:a,factoryContract:t,createAccountOverride:r,accountSalt:n}=e;if(r)return r(t,a);const s=n&&W(n)?n:z(n??"");return E({contract:t,method:"function createAccount(address, bytes) returns (address)",params:[a,s]})}function se(e){const{accountContract:a,transaction:t,executeOverride:r}=e;if(r)return r(a,t);let n=t.value||0n;return(t.chainId===295||t.chainId===296)&&(n=BigInt(n)/BigInt(10**10)),E({contract:a,gas:t.gas?t.gas+21000n:void 0,method:"function execute(address, uint256, bytes)",params:[t.to||"",n,t.data||"0x"]})}function Re(e){const{accountContract:a,transactions:t,executeBatchOverride:r}=e;if(r)return r(a,t);let n=t.map(c=>c.value||0n);const s=t[0]?.chainId;return(s===295||s===296)&&(n=n.map(c=>BigInt(c)/BigInt(10**10))),E({contract:a,method:"function executeBatch(address[], uint256[], bytes[])",params:[t.map(c=>c.to||""),n,t.map(c=>c.data||"0x")]})}const ke="0xdd62ed3e",He=[{name:"owner",type:"address"},{name:"spender",type:"address"}],Be=[{type:"uint256"}];async function Me(e){return L({contract:e.contract,method:[ke,He,Be],params:[e.owner,e.spender]})}const qe="0x095ea7b3",We=[{name:"spender",type:"address"},{name:"value",type:"uint256"}],ze=[{type:"bool"}];function Ke(e){const a=ee(async()=>"asyncParams"in e?await e.asyncParams():e);return E({accessList:async()=>(await a()).overrides?.accessList,authorizationList:async()=>(await a()).overrides?.authorizationList,contract:e.contract,erc20Value:async()=>(await a()).overrides?.erc20Value,extraGas:async()=>(await a()).overrides?.extraGas,gas:async()=>(await a()).overrides?.gas,gasPrice:async()=>(await a()).overrides?.gasPrice,maxFeePerGas:async()=>(await a()).overrides?.maxFeePerGas,maxPriorityFeePerGas:async()=>(await a()).overrides?.maxPriorityFeePerGas,method:[qe,We,ze],nonce:async()=>(await a()).overrides?.nonce,params:async()=>{const t=await a();return[t.spender,t.value]},value:async()=>(await a()).overrides?.value})}function je(e){return Ke({asyncParams:async()=>{let a;if("amount"in e){const{decimals:t}=await x(async()=>{const{decimals:n}=await import("./decimals-BQ2RiGna.js");return{decimals:n}},__vite__mapDeps([0,1,2,3,4,5])),r=await t(e).catch(()=>18);a=Te(e.amount.toString(),r)}else a=e.amountWei;return{overrides:{erc20Value:{amountWei:a,tokenAddress:e.contract.address}},spender:e.spender,value:a}},contract:e.contract})}const Ze="0xf15d424e",Ye=[{name:"signer",type:"address"}],Je=[{components:[{name:"signer",type:"address"},{name:"approvedTargets",type:"address[]"},{name:"nativeTokenLimitPerTransaction",type:"uint256"},{name:"startTimestamp",type:"uint128"},{name:"endTimestamp",type:"uint128"}],name:"permissions",type:"tuple"}];async function Qe(e){return L({contract:e.contract,method:[Ze,Ye,Je],params:[e.signer]})}const Xe="0x5892e236",et=[{components:[{name:"signer",type:"address"},{name:"isAdmin",type:"uint8"},{name:"approvedTargets",type:"address[]"},{name:"nativeTokenLimitPerTransaction",type:"uint256"},{name:"permissionStartTimestamp",type:"uint128"},{name:"permissionEndTimestamp",type:"uint128"},{name:"reqValidityStartTimestamp",type:"uint128"},{name:"reqValidityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],name:"req",type:"tuple"},{name:"signature",type:"bytes"}],tt=[];function at(e){const a=ee(async()=>"asyncParams"in e?await e.asyncParams():e);return E({accessList:async()=>(await a()).overrides?.accessList,authorizationList:async()=>(await a()).overrides?.authorizationList,contract:e.contract,erc20Value:async()=>(await a()).overrides?.erc20Value,extraGas:async()=>(await a()).overrides?.extraGas,gas:async()=>(await a()).overrides?.gas,gasPrice:async()=>(await a()).overrides?.gasPrice,maxFeePerGas:async()=>(await a()).overrides?.maxFeePerGas,maxPriorityFeePerGas:async()=>(await a()).overrides?.maxPriorityFeePerGas,method:[Xe,et,tt],nonce:async()=>(await a()).overrides?.nonce,params:async()=>{const t=await a();return[t.req,t.signature]},value:async()=>(await a()).overrides?.value})}function q(){return new Date(Date.now()+1e3*60*60*24*365*10)}function N(e){return Ee(Math.floor(e.getTime()/1e3))}const st=[{name:"signer",type:"address"},{name:"isAdmin",type:"uint8"},{name:"approvedTargets",type:"address[]"},{name:"nativeTokenLimitPerTransaction",type:"uint256"},{name:"permissionStartTimestamp",type:"uint128"},{name:"permissionEndTimestamp",type:"uint128"},{name:"reqValidityStartTimestamp",type:"uint128"},{name:"reqValidityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}];async function nt(e){const{account:a,contract:t,req:r}=e,n=await a.signTypedData({domain:{chainId:t.chain.id,name:"Account",verifyingContract:t.address,version:"1"},message:r,primaryType:"SignerPermissionRequest",types:{SignerPermissionRequest:st}});return{req:r,signature:n}}async function rt(e){const{target:a,permissions:t}=e;return{approvedTargets:t.approvedTargets==="*"?[te]:t.approvedTargets,isAdmin:0,nativeTokenLimitPerTransaction:X(t.nativeTokenLimitPerTransaction?.toString()||"0"),permissionEndTimestamp:N(t.permissionEndTimestamp||q()),permissionStartTimestamp:N(t.permissionStartTimestamp||new Date(0)),reqValidityEndTimestamp:N(q()),reqValidityStartTimestamp:0n,signer:a,uid:await Ve()}}function it(e){const{contract:a,sessionKeyAddress:t,account:r,permissions:n}=e;return at({async asyncParams(){const{req:s,signature:c}=await nt({account:r,contract:a,req:await rt({permissions:n,target:t})});return{req:s,signature:c}},contract:a})}async function ct(e){const{accountContract:a,sessionKeyAddress:t,newPermissions:r}=e;if(!await K(a))return!0;const s=await Qe({contract:a,signer:t});return!!(s.endTimestamp&&s.endTimestamp<Math.floor(Date.now()/1e3)||!ot(s.approvedTargets,r.approvedTargets)||X(r.nativeTokenLimitPerTransaction?.toString()??"0")>s.nativeTokenLimitPerTransaction)}function ot(e,a){return a==="*"&&e.length===1&&e[0]===te?!0:a!=="*"?a.map(t=>t.toLowerCase()).every(t=>e.map(r=>r.toLowerCase()).includes(t)):!1}const dt=2n**96n-1n,mt="0x35567e1a",ut=[{name:"sender",type:"address"},{name:"key",type:"uint192"}],pt=[{name:"nonce",type:"uint256"}];async function yt(e){return L({contract:e.contract,method:[mt,ut,pt],params:[e.sender,e.key]})}const lt="0xa6193531",ft=[{components:[{name:"sender",type:"address"},{name:"nonce",type:"uint256"},{name:"initCode",type:"bytes"},{name:"callData",type:"bytes"},{name:"callGasLimit",type:"uint256"},{name:"verificationGasLimit",type:"uint256"},{name:"preVerificationGas",type:"uint256"},{name:"maxFeePerGas",type:"uint256"},{name:"maxPriorityFeePerGas",type:"uint256"},{name:"paymasterAndData",type:"bytes"},{name:"signature",type:"bytes"}],name:"userOp",type:"tuple"}],wt=[{type:"bytes32"}];async function At(e){return L({contract:e.contract,method:[lt,ft,wt],params:[e.userOp]})}const vt="0x22cdde4c",ht=[{components:[{name:"sender",type:"address"},{name:"nonce",type:"uint256"},{name:"initCode",type:"bytes"},{name:"callData",type:"bytes"},{name:"accountGasLimits",type:"bytes32"},{name:"preVerificationGas",type:"uint256"},{name:"gasFees",type:"bytes32"},{name:"paymasterAndData",type:"bytes"},{name:"signature",type:"bytes"}],name:"userOp",type:"tuple"}],gt=[{type:"bytes32"}];async function Gt(e){return L({contract:e.contract,method:[vt,ht,gt],params:[e.userOp]})}function Tt(e){return e.factory?F([e.factory,e.factoryData||"0x"]):"0x"}function Pt(e){return F([D(C(BigInt(e.verificationGasLimit)),{size:16}),D(C(BigInt(e.callGasLimit)),{size:16})])}function xt(e){return F([D(C(BigInt(e.maxPriorityFeePerGas)),{size:16}),D(C(BigInt(e.maxFeePerGas)),{size:16})])}function Lt(e){return e.paymaster?F([e.paymaster,D(C(BigInt(e.paymasterVerificationGasLimit||0)),{size:16}),D(C(BigInt(e.paymasterPostOpGasLimit||0)),{size:16}),e.paymasterData||"0x"]):"0x"}const Ot=e=>({accountGasLimits:Pt(e),callData:e.callData,gasFees:xt(e),initCode:Tt(e),nonce:BigInt(e.nonce),paymasterAndData:Lt(e),preVerificationGas:BigInt(e.preVerificationGas),sender:e.sender,signature:e.signature});async function U(e){const{userOp:a,paymasterOverride:t,client:r,chain:n,entrypointAddress:s}=e;if(t)return t(a);const c={"Content-Type":"application/json"},i=s??S,m=j(n),u={id:1,jsonrpc:"2.0",method:"pm_sponsorUserOperation",params:[Le(a),i]},l=await ue(r)(m,{body:Z(u),headers:c,method:"POST"});if(!l.ok){const A=await l.text()||l.statusText;throw new Error(`Paymaster error: ${l.status} - ${A}`)}const o=await l.json();if(o.result)return typeof o.result=="string"?{paymasterAndData:o.result}:(o.result.reason&&console.warn(`Paymaster policy rejected this transaction with reason: ${o.result.reason} ${o.result.policyId?`(policyId: ${o.result.policyId})`:""}`),{callGasLimit:o.result.callGasLimit?_(o.result.callGasLimit):void 0,paymaster:o.result.paymaster,paymasterAndData:o.result.paymasterAndData,paymasterData:o.result.paymasterData,paymasterPostOpGasLimit:o.result.paymasterPostOpGasLimit?_(o.result.paymasterPostOpGasLimit):void 0,paymasterVerificationGasLimit:o.result.paymasterVerificationGasLimit?_(o.result.paymasterVerificationGasLimit):void 0,preVerificationGas:o.result.preVerificationGas?_(o.result.preVerificationGas):void 0,verificationGasLimit:o.result.verificationGasLimit?_(o.result.verificationGasLimit):void 0});const w=o.error?.message||o.error||l.statusText||"unknown error";throw new Error(`Paymaster error from ${m}: ${w}`)}const B=new Set,M=e=>`${e.chain.id}:${e.address}`,ne=e=>{B.add(M(e))},re=e=>{B.delete(M(e))},ie=e=>B.has(M(e));async function Dt(e){const a=e.timeoutMs||12e4,t=e.intervalMs||1e3,r=Date.now()+a;for(;Date.now()<r;){const n=await Oe(e);if(n)return n;await new Promise(s=>setTimeout(s,t))}throw new Error(`Timeout waiting for userOp to be mined on chain ${e.chain.id} with UserOp hash: ${e.userOpHash}`)}async function Ct(e){const{transaction:a,accountContract:t,factoryContract:r,adminAddress:n,overrides:s,sponsorGas:c,waitForDeployment:i=!0,isDeployedOverride:m}=e,u=a.chain,y=a.client,l={bundlerUrl:s?.bundlerUrl,chain:u,client:y,entrypointAddress:s?.entrypointAddress},o=k(e.overrides?.entrypointAddress||S),[w,A,v,h,f]=await Promise.all([typeof m=="boolean"?m:K(t).then(P=>P||ie(t)),H(a),O(a.gas),St({bundlerOptions:l,chain:u,client:y,executeTx:a}),Vt({accountContract:t,chain:u,client:y,entrypointAddress:s?.entrypointAddress,getNonceOverride:s?.getAccountNonce})]),{maxFeePerGas:d,maxPriorityFeePerGas:p}=h;return o==="v0.7"?_t({accountContract:t,adminAddress:n,bundlerOptions:l,callData:A,callGasLimit:v,factoryContract:r,isDeployed:w,maxFeePerGas:d,maxPriorityFeePerGas:p,nonce:f,overrides:s,sponsorGas:c,waitForDeployment:i}):Ft({accountContract:t,adminAddress:n,bundlerOptions:l,callData:A,callGasLimit:v,factoryContract:r,isDeployed:w,maxFeePerGas:d,maxPriorityFeePerGas:p,nonce:f,overrides:s,sponsorGas:c,waitForDeployment:i})}async function St(e){const{executeTx:a,bundlerOptions:t,chain:r,client:n}=e;let{maxFeePerGas:s,maxPriorityFeePerGas:c}=a;const i=t?.bundlerUrl??j(r);if(ye(i)){const m=await De({options:t});s=m.maxFeePerGas,c=m.maxPriorityFeePerGas}else{const[m,u]=await Promise.all([O(s),O(c)]);if(m&&u)s=m,c=u;else{const y=await Pe(n,r);c=u??y.maxPriorityFeePerGas??0n,s=m??y.maxFeePerGas??0n}}return{maxFeePerGas:s,maxPriorityFeePerGas:c}}async function _t(e){const{bundlerOptions:a,isDeployed:t,factoryContract:r,accountContract:n,adminAddress:s,sponsorGas:c,overrides:i,nonce:m,callData:u,callGasLimit:y,maxFeePerGas:l,maxPriorityFeePerGas:o,waitForDeployment:w}=e,{chain:A,client:v}=a;let h,f;t?(f="0x",w&&await ce(n)):(h=r.address,f=await H(ae({accountSalt:i?.accountSalt,adminAddress:s,createAccountOverride:i?.createAccount,factoryContract:r})),w&&ne(n));const d={callData:u,callGasLimit:y??0n,factory:h,factoryData:f,maxFeePerGas:l,maxPriorityFeePerGas:o,nonce:m,paymaster:void 0,paymasterData:"0x",paymasterPostOpGasLimit:0n,paymasterVerificationGasLimit:0n,preVerificationGas:0n,sender:n.address,signature:Y,verificationGasLimit:0n};if(c){const p=await U({chain:A,client:v,entrypointAddress:i?.entrypointAddress,paymasterOverride:i?.paymaster,userOp:d});if(p.paymaster&&p.paymasterData&&(d.paymaster=p.paymaster,d.paymasterData=p.paymasterData),p.callGasLimit&&p.verificationGasLimit&&p.preVerificationGas&&p.paymasterPostOpGasLimit&&p.paymasterVerificationGasLimit)d.callGasLimit=p.callGasLimit,d.verificationGasLimit=p.verificationGasLimit,d.preVerificationGas=p.preVerificationGas,d.paymasterPostOpGasLimit=p.paymasterPostOpGasLimit,d.paymasterVerificationGasLimit=p.paymasterVerificationGasLimit;else{const P=i?.tokenPaymaster?{[i.tokenPaymaster.tokenAddress]:{stateDiff:{[le(Ne([{type:"address"},{type:"uint256"}],[n.address,i.tokenPaymaster.balanceStorageSlot]))]:fe(we,{size:32})}}}:void 0,g=await V({options:a,userOp:d},P);d.callGasLimit=g.callGasLimit,d.verificationGasLimit=g.verificationGasLimit,d.preVerificationGas=g.preVerificationGas,d.paymasterPostOpGasLimit=i?.tokenPaymaster?500000n:g.paymasterPostOpGasLimit||0n,d.paymasterVerificationGasLimit=g.paymasterVerificationGasLimit||0n;const G=await U({chain:A,client:v,entrypointAddress:i?.entrypointAddress,paymasterOverride:i?.paymaster,userOp:d});G.paymaster&&G.paymasterData&&(d.paymaster=G.paymaster,d.paymasterData=G.paymasterData)}}else{const p=await V({options:a,userOp:d});d.callGasLimit=p.callGasLimit,d.verificationGasLimit=p.verificationGasLimit,d.preVerificationGas=p.preVerificationGas,d.paymasterPostOpGasLimit=p.paymasterPostOpGasLimit||0n,d.paymasterVerificationGasLimit=p.paymasterVerificationGasLimit||0n}return{...d,signature:"0x"}}async function Ft(e){const{bundlerOptions:a,isDeployed:t,factoryContract:r,accountContract:n,adminAddress:s,sponsorGas:c,overrides:i,nonce:m,callData:u,callGasLimit:y,maxFeePerGas:l,maxPriorityFeePerGas:o,waitForDeployment:w}=e,{chain:A,client:v}=a;let h;t?(h="0x",w&&await ce(n)):(h=await It({accountSalt:i?.accountSalt,adminAddress:s,createAccountOverride:i?.createAccount,factoryContract:r}),w&&ne(n));const f={callData:u,callGasLimit:y??0n,initCode:h,maxFeePerGas:l,maxPriorityFeePerGas:o,nonce:m,paymasterAndData:"0x",preVerificationGas:0n,sender:n.address,signature:Y,verificationGasLimit:0n};if(c){const d=await U({chain:A,client:v,entrypointAddress:i?.entrypointAddress,paymasterOverride:i?.paymaster,userOp:f}),p="paymasterAndData"in d?d.paymasterAndData:"0x";if(p&&p!=="0x"&&(f.paymasterAndData=p),d.callGasLimit&&d.verificationGasLimit&&d.preVerificationGas)f.callGasLimit=d.callGasLimit,f.verificationGasLimit=d.verificationGasLimit,f.preVerificationGas=d.preVerificationGas;else{const P=await V({options:a,userOp:f});if(f.callGasLimit=P.callGasLimit,f.verificationGasLimit=P.verificationGasLimit,f.preVerificationGas=P.preVerificationGas,p&&p!=="0x"){const g=await U({chain:A,client:v,entrypointAddress:i?.entrypointAddress,paymasterOverride:i?.paymaster,userOp:f}),G="paymasterAndData"in g?g.paymasterAndData:"0x";G&&G!=="0x"&&(f.paymasterAndData=G)}}}else{const d=await V({options:a,userOp:f});f.callGasLimit=d.callGasLimit,f.verificationGasLimit=d.verificationGasLimit,f.preVerificationGas=d.preVerificationGas}return{...f,signature:"0x"}}async function Et(e){const{userOp:a,chain:t,entrypointAddress:r,adminAccount:n}=e,s=await bt({chain:t,client:e.client,entrypointAddress:r,userOp:a});if(n.signMessage){const c=await n.signMessage({chainId:t.id,message:{raw:pe(s)},originalMessage:Z(a)});return{...a,signature:c}}throw new Error("signMessage not implemented in signingAccount")}async function bt(e){const{userOp:a,chain:t,entrypointAddress:r}=e,n=k(r||S);let s;if(n==="v0.7"){const c=Ot(a);s=await Gt({contract:T({address:r||J,chain:t,client:e.client}),userOp:c})}else s=await At({contract:T({address:r||S,chain:t,client:e.client}),userOp:a});return s}async function It(e){const{factoryContract:a,adminAddress:t,accountSalt:r,createAccountOverride:n}=e,s=ae({accountSalt:r,adminAddress:t,createAccountOverride:n,factoryContract:a});return F([a.address,await H(s)])}async function Vt(e){const{accountContract:a,chain:t,client:r,entrypointAddress:n,getNonceOverride:s}=e;return s?s(a):await yt({contract:T({address:n||S,chain:t,client:r}),key:Ce(),sender:a.address})}async function ce(e){const a=Date.now();for(;ie(e);){if(Date.now()-a>6e4)throw re(e),new Error("Account deployment is taking too long (over 1 minute). Please try again.");await new Promise(t=>setTimeout(t,500))}}const oe=new WeakMap,$=new WeakMap;async function Ut(e,a){const{personalAccount:t,client:r}=e;if(!t)throw new Error("No personal account provided for smart account connection");const n=a,s=a.chain,c="gasless"in n?n.gasless:n.sponsorGas;if(await Ae(s))return[kt({chain:s,connectionOptions:e,creationOptions:a,sponsorGas:c}),s];if(n.factoryAddress&&!n.overrides?.entrypointAddress){const o=await de(n.factoryAddress,r,s);o&&(n.overrides={...n.overrides,entrypointAddress:o})}n.overrides?.tokenPaymaster&&!n.overrides?.entrypointAddress&&(n.overrides={...n.overrides,entrypointAddress:J});const i=n.factoryAddress??ve(n.overrides?.entrypointAddress),m=T({address:i,chain:s,client:r}),u=await $e({accountAddress:n.overrides?.accountAddress,accountSalt:n.overrides?.accountSalt,adminAddress:t.address,factoryContract:m,predictAddressOverride:n.overrides?.predictAddress}).then(o=>o).catch(o=>{throw new Error(`Failed to get account address with factory contract ${m.address} on chain ID ${s.id}: ${o?.message||"unknown error"}`,{cause:o})}),y=T({address:u,chain:s,client:r}),l=await $t({...n,accountContract:y,chain:s,client:r,factoryContract:m,personalAccount:t,sponsorGas:c});if(oe.set(t,l),$.set(l,t),n.sessionKey&&await ct({accountContract:y,newPermissions:n.sessionKey.permissions,sessionKeyAddress:n.sessionKey.address})){const o=it({account:t,contract:y,permissions:n.sessionKey.permissions,sessionKeyAddress:n.sessionKey.address});await Ue({account:l,transaction:o})}return[l,s]}async function Nt(e){const a=$.get(e);a&&(oe.delete(a),$.delete(e))}async function $t(e){const a=e.overrides?.tokenPaymaster;if(a&&k(e.overrides?.entrypointAddress||S)!=="v0.7")throw new Error("Token paymaster is only supported for entrypoint version v0.7");const t=e.sponsorGas;let r=e.accountContract;const n={address:Q(r.address),async onTransactionRequested(s){return e.personalAccount.onTransactionRequested?.(s)},async sendBatchTransaction(s){const c=Re({accountContract:r,executeBatchOverride:e.overrides?.executeBatch,transactions:s});if(s.length===0)throw new Error("No transactions to send");const i=s[0];if(!i)throw new Error("No transactions to send");const m=b(i.chainId),u=await R({executeTx:c,options:{...e,accountContract:r,chain:m}});return I({chainId:m.id,client:e.client,contractAddress:s[0]?.to??void 0,transactionHash:u.transactionHash,walletAddress:e.accountContract.address,walletType:"smart"}),u},async sendTransaction(s){let c;if(a){await Rt({accountContract:r,erc20Paymaster:a,options:e});const y=async()=>({paymaster:a.paymasterAddress,paymasterData:"0x"});c=e.overrides?.paymaster||y}else c=e.overrides?.paymaster;s.chainId!==r.chain.id&&(r=T({address:n.address,chain:b(s.chainId),client:e.client}));const i=se({accountContract:r,executeOverride:e.overrides?.execute,transaction:s}),m=b(s.chainId),u=await R({executeTx:i,options:{...e,accountContract:r,chain:m,overrides:{...e.overrides,paymaster:c}}});return I({chainId:m.id,client:e.client,contractAddress:s.to??void 0,transactionHash:u.transactionHash,walletAddress:e.accountContract.address,walletType:"smart"}),u},async signMessage({message:s}){if(e.overrides?.signMessage)return e.overrides.signMessage({accountContract:r,adminAccount:e.personalAccount,factoryContract:e.factoryContract,message:s});const{smartAccountSignMessage:c}=await x(async()=>{const{smartAccountSignMessage:i}=await import("./signing-BGN0s6tt.js");return{smartAccountSignMessage:i}},__vite__mapDeps([6,4,1,2,5,7,3,8,9,10,11,12,13]));return c({accountContract:r,factoryContract:e.factoryContract,message:s,options:e})},async signTypedData(s){if(e.overrides?.signTypedData)return e.overrides.signTypedData({accountContract:r,adminAccount:e.personalAccount,factoryContract:e.factoryContract,typedData:s});const{smartAccountSignTypedData:c}=await x(async()=>{const{smartAccountSignTypedData:i}=await import("./signing-BGN0s6tt.js");return{smartAccountSignTypedData:i}},__vite__mapDeps([6,4,1,2,5,7,3,8,9,10,11,12,13]));return c({accountContract:r,factoryContract:e.factoryContract,options:e,typedData:s})},sendCalls:async s=>{const{inAppWalletSendCalls:c}=await x(async()=>{const{inAppWalletSendCalls:l}=await import("./in-app-wallet-calls-DoVweYsf.js");return{inAppWalletSendCalls:l}},__vite__mapDeps([14,15,1,2,5,16,13,12])),i=s.calls[0];if(!i)throw new Error("No calls to send");const m=i.client,u=i.chain||s.chain,y=await c({account:n,calls:s.calls});return{chain:u,client:m,id:y}},getCallsStatus:async s=>{const{inAppWalletGetCallsStatus:c}=await x(async()=>{const{inAppWalletGetCallsStatus:i}=await import("./in-app-wallet-calls-DoVweYsf.js");return{inAppWalletGetCallsStatus:i}},__vite__mapDeps([14,15,1,2,5,16,13,12]));return c(s)},getCapabilities:async s=>({[s.chainId??1]:{atomic:{status:"supported"},paymasterService:{supported:t??!1}}})};return n}async function Rt(e){const{accountContract:a,erc20Paymaster:t,options:r}=e,n=t.tokenAddress,s=T({address:n,chain:a.chain,client:a.client});if(await Me({contract:s,owner:a.address,spender:t.paymasterAddress})>0n)return;const i=je({amountWei:dt-1n,contract:s,spender:t.paymasterAddress}),m=await xe({from:a.address,transaction:i}),u=se({accountContract:a,executeOverride:r.overrides?.execute,transaction:m});await R({executeTx:u,options:{...r,overrides:{...r.overrides,tokenPaymaster:void 0}}})}function kt(e){const{creationOptions:a,connectionOptions:t,chain:r}=e,n={address:Q(t.personalAccount.address),async onTransactionRequested(s){return t.personalAccount.onTransactionRequested?.(s)},async sendTransaction(s){const c={chain:b(s.chainId),client:t.client,data:s.data,eip712:s.eip712,to:s.to??void 0,value:s.value??0n};let i=await be({account:n,transaction:c});if(e.sponsorGas&&!i.paymaster){const y=await Se({options:{bundlerUrl:a.overrides?.bundlerUrl,chain:r,client:t.client,entrypointAddress:a.overrides?.entrypointAddress},transaction:i});i={...i,...y}}const m=await Ie({account:n,chainId:r.id,eip712Transaction:i}),u=await _e({options:{bundlerUrl:a.overrides?.bundlerUrl,chain:r,client:t.client,entrypointAddress:a.overrides?.entrypointAddress},signedTransaction:m,transaction:i});return I({chainId:r.id,client:t.client,contractAddress:s.to??void 0,transactionHash:u.transactionHash,walletAddress:n.address,walletType:"smart"}),{chain:r,client:t.client,transactionHash:u.transactionHash}},async signMessage({message:s}){return t.personalAccount.signMessage({message:s})},async signTypedData(s){const c=he(s);return t.personalAccount.signTypedData(c)},sendCalls:async s=>{const{inAppWalletSendCalls:c}=await x(async()=>{const{inAppWalletSendCalls:l}=await import("./in-app-wallet-calls-DoVweYsf.js");return{inAppWalletSendCalls:l}},__vite__mapDeps([14,15,1,2,5,16,13,12])),i=s.calls[0];if(!i)throw new Error("No calls to send");const m=i.client,u=i.chain||s.chain,y=await c({account:n,calls:s.calls});return{chain:u,client:m,id:y}},getCallsStatus:async s=>{const{inAppWalletGetCallsStatus:c}=await x(async()=>{const{inAppWalletGetCallsStatus:i}=await import("./in-app-wallet-calls-DoVweYsf.js");return{inAppWalletGetCallsStatus:i}},__vite__mapDeps([14,15,1,2,5,16,13,12]));return c(s)},getCapabilities:async s=>({[s.chainId??1]:{atomic:{status:"unsupported"},paymasterService:{supported:e.sponsorGas??!1}}})};return n}async function R(e){const{executeTx:a,options:t}=e;try{const r=await Ct({accountContract:t.accountContract,adminAddress:t.personalAccount.address,factoryContract:t.factoryContract,overrides:t.overrides,sponsorGas:t.sponsorGas,transaction:a}),n=await Et({adminAccount:t.personalAccount,chain:t.chain,client:t.client,entrypointAddress:t.overrides?.entrypointAddress,userOp:r}),s={bundlerUrl:t.overrides?.bundlerUrl,chain:t.chain,client:t.client,entrypointAddress:t.overrides?.entrypointAddress},c=await Fe({options:s,userOp:n}),i=await Dt({...s,userOpHash:c});return I({chainId:t.chain.id,client:t.client,contractAddress:await O(a.to??void 0),transactionHash:i.transactionHash,walletAddress:t.accountContract.address,walletType:"smart"}),{chain:t.chain,client:t.client,transactionHash:i.transactionHash}}catch(r){throw ge(r)&&Ge({chainId:t.chain.id,client:t.client,contractAddress:await O(a.to??void 0),error:r,transactionValue:await O(a.value),walletAddress:t.accountContract.address}),r}finally{re(t.accountContract)}}async function de(e,a,t){const r=T({address:e,chain:t,client:a});try{return await L({contract:r,method:"function entrypoint() public view returns (address)"})}catch{return}}const Yt=Object.freeze(Object.defineProperty({__proto__:null,connectSmartAccount:Ut,disconnectSmartAccount:Nt,getEntrypointFromFactory:de},Symbol.toStringTag,{value:"Module"}));export{Yt as i,ae as p};
