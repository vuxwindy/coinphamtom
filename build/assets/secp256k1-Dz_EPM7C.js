import{a$ as nt,b0 as qt,b1 as ht,d as ue,b2 as D,b3 as ae,a as le,b4 as Ct,b5 as de}from"./index-W7O16Knq.js";import{h as he}from"./hmac-DLbHqf-0.js";/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Nt=BigInt(0),xt=BigInt(1);function wt(e,n=""){if(typeof e!="boolean"){const r=n&&`"${n}"`;throw new Error(r+"expected boolean, got type="+typeof e)}return e}function W(e,n,r=""){const t=qt(e),o=e?.length,i=n!==void 0;if(!t||i&&o!==n){const s=r&&`"${r}" `,l=i?` of length ${n}`:"",a=t?`length=${o}`:`type=${typeof e}`;throw new Error(s+"expected Uint8Array"+l+", got "+a)}return e}function lt(e){const n=e.toString(16);return n.length&1?"0"+n:n}function kt(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);return e===""?Nt:BigInt("0x"+e)}function mt(e){return kt(nt(e))}function zt(e){return ue(e),kt(nt(Uint8Array.from(e).reverse()))}function Rt(e,n){return ht(e.toString(16).padStart(n*2,"0"))}function Ht(e,n){return Rt(e,n).reverse()}function j(e,n,r){let t;if(typeof n=="string")try{t=ht(n)}catch(o){throw new Error(e+" must be hex string or Uint8Array, cause: "+o)}else if(qt(n))t=Uint8Array.from(n);else throw new Error(e+" must be hex string or Uint8Array");return t.length,t}const yt=e=>typeof e=="bigint"&&Nt<=e;function we(e,n,r){return yt(e)&&yt(n)&&yt(r)&&n<=e&&e<r}function ge(e,n,r,t){if(!we(n,r,t))throw new Error("expected valid "+e+": "+r+" <= n < "+t+", got "+n)}function Xt(e){let n;for(n=0;e>Nt;e>>=xt,n+=1);return n}const st=e=>(xt<<BigInt(e))-xt;function me(e,n,r){if(typeof e!="number"||e<2)throw new Error("hashLen must be a number");if(typeof n!="number"||n<2)throw new Error("qByteLen must be a number");if(typeof r!="function")throw new Error("hmacFn must be a function");const t=h=>new Uint8Array(h),o=h=>Uint8Array.of(h);let i=t(e),s=t(e),l=0;const a=()=>{i.fill(1),s.fill(0),l=0},w=(...h)=>r(s,i,...h),y=(h=t(0))=>{s=w(o(0),h),i=w(),h.length!==0&&(s=w(o(1),h),i=w())},I=()=>{if(l++>=1e3)throw new Error("drbg: tried 1000 values");let h=0;const E=[];for(;h<n;){i=w();const x=i.slice();E.push(x),h+=i.length}return D(...E)};return(h,E)=>{a(),y(h);let x;for(;!(x=E(I()));)y();return a(),x}}function Ot(e,n,r={}){if(!e||typeof e!="object")throw new Error("expected valid options object");function t(o,i,s){const l=e[o];if(s&&l===void 0)return;const a=typeof l;if(a!==i||l===null)throw new Error(`param "${o}" is invalid: expected ${i}, got ${a}`)}Object.entries(n).forEach(([o,i])=>t(o,i,!1)),Object.entries(r).forEach(([o,i])=>t(o,i,!0))}function Tt(e){const n=new WeakMap;return(r,...t)=>{const o=n.get(r);if(o!==void 0)return o;const i=e(r,...t);return n.set(r,i),i}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const M=BigInt(0),K=BigInt(1),Q=BigInt(2),Dt=BigInt(3),Gt=BigInt(4),Ft=BigInt(5),ye=BigInt(7),Wt=BigInt(8),be=BigInt(9),Qt=BigInt(16);function k(e,n){const r=e%n;return r>=M?r:n+r}function C(e,n,r){let t=e;for(;n-- >M;)t*=t,t%=r;return t}function Vt(e,n){if(e===M)throw new Error("invert: expected non-zero number");if(n<=M)throw new Error("invert: expected positive modulus, got "+n);let r=k(e,n),t=n,o=M,i=K;for(;r!==M;){const l=t/r,a=t%r,w=o-i*l;t=r,r=a,o=i,i=w}if(t!==K)throw new Error("invert: does not exist");return k(o,n)}function At(e,n,r){if(!e.eql(e.sqr(n),r))throw new Error("Cannot find square root")}function Pt(e,n){const r=(e.ORDER+K)/Gt,t=e.pow(n,r);return At(e,t,n),t}function Ee(e,n){const r=(e.ORDER-Ft)/Wt,t=e.mul(n,Q),o=e.pow(t,r),i=e.mul(n,o),s=e.mul(e.mul(i,Q),o),l=e.mul(i,e.sub(s,e.ONE));return At(e,l,n),l}function pe(e){const n=ct(e),r=Jt(e),t=r(n,n.neg(n.ONE)),o=r(n,t),i=r(n,n.neg(t)),s=(e+ye)/Qt;return(l,a)=>{let w=l.pow(a,s),y=l.mul(w,t);const I=l.mul(w,o),f=l.mul(w,i),h=l.eql(l.sqr(y),a),E=l.eql(l.sqr(I),a);w=l.cmov(w,y,h),y=l.cmov(f,I,E);const x=l.eql(l.sqr(y),a),O=l.cmov(w,y,x);return At(l,O,a),O}}function Jt(e){if(e<Dt)throw new Error("sqrt is not defined for small field");let n=e-K,r=0;for(;n%Q===M;)n/=Q,r++;let t=Q;const o=ct(e);for(;$t(o,t)===1;)if(t++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(r===1)return Pt;let i=o.pow(t,n);const s=(n+K)/Q;return function(a,w){if(a.is0(w))return w;if($t(a,w)!==1)throw new Error("Cannot find square root");let y=r,I=a.mul(a.ONE,i),f=a.pow(w,n),h=a.pow(w,s);for(;!a.eql(f,a.ONE);){if(a.is0(f))return a.ZERO;let E=1,x=a.sqr(f);for(;!a.eql(x,a.ONE);)if(E++,x=a.sqr(x),E===y)throw new Error("Cannot find square root");const O=K<<BigInt(y-E-1),U=a.pow(I,O);y=E,I=a.sqr(U),f=a.mul(f,I),h=a.mul(h,U)}return h}}function Be(e){return e%Gt===Dt?Pt:e%Wt===Ft?Ee:e%Qt===be?pe(e):Jt(e)}const ve=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function xe(e){const n={ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"},r=ve.reduce((t,o)=>(t[o]="function",t),n);return Ot(e,r),e}function Se(e,n,r){if(r<M)throw new Error("invalid exponent, negatives unsupported");if(r===M)return e.ONE;if(r===K)return n;let t=e.ONE,o=n;for(;r>M;)r&K&&(t=e.mul(t,o)),o=e.sqr(o),r>>=K;return t}function te(e,n,r=!1){const t=new Array(n.length).fill(r?e.ZERO:void 0),o=n.reduce((s,l,a)=>e.is0(l)?s:(t[a]=s,e.mul(s,l)),e.ONE),i=e.inv(o);return n.reduceRight((s,l,a)=>e.is0(l)?s:(t[a]=e.mul(s,t[a]),e.mul(s,l)),i),t}function $t(e,n){const r=(e.ORDER-K)/Q,t=e.pow(n,r),o=e.eql(t,e.ONE),i=e.eql(t,e.ZERO),s=e.eql(t,e.neg(e.ONE));if(!o&&!i&&!s)throw new Error("invalid Legendre symbol result");return o?1:i?0:-1}function ee(e,n){n!==void 0&&ae(n);const r=n!==void 0?n:e.toString(2).length,t=Math.ceil(r/8);return{nBitLength:r,nByteLength:t}}function ct(e,n,r=!1,t={}){if(e<=M)throw new Error("invalid field: expected ORDER > 0, got "+e);let o,i,s=!1,l;if(typeof n=="object"&&n!=null){if(t.sqrt||r)throw new Error("cannot specify opts in two arguments");const f=n;f.BITS&&(o=f.BITS),f.sqrt&&(i=f.sqrt),typeof f.isLE=="boolean"&&(r=f.isLE),typeof f.modFromBytes=="boolean"&&(s=f.modFromBytes),l=f.allowedLengths}else typeof n=="number"&&(o=n),t.sqrt&&(i=t.sqrt);const{nBitLength:a,nByteLength:w}=ee(e,o);if(w>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let y;const I=Object.freeze({ORDER:e,isLE:r,BITS:a,BYTES:w,MASK:st(a),ZERO:M,ONE:K,allowedLengths:l,create:f=>k(f,e),isValid:f=>{if(typeof f!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof f);return M<=f&&f<e},is0:f=>f===M,isValidNot0:f=>!I.is0(f)&&I.isValid(f),isOdd:f=>(f&K)===K,neg:f=>k(-f,e),eql:(f,h)=>f===h,sqr:f=>k(f*f,e),add:(f,h)=>k(f+h,e),sub:(f,h)=>k(f-h,e),mul:(f,h)=>k(f*h,e),pow:(f,h)=>Se(I,f,h),div:(f,h)=>k(f*Vt(h,e),e),sqrN:f=>f*f,addN:(f,h)=>f+h,subN:(f,h)=>f-h,mulN:(f,h)=>f*h,inv:f=>Vt(f,e),sqrt:i||(f=>(y||(y=Be(e)),y(I,f))),toBytes:f=>r?Ht(f,w):Rt(f,w),fromBytes:(f,h=!0)=>{if(l){if(!l.includes(f.length)||f.length>w)throw new Error("Field.fromBytes: expected "+l+" bytes, got "+f.length);const x=new Uint8Array(w);x.set(f,r?0:x.length-f.length),f=x}if(f.length!==w)throw new Error("Field.fromBytes: expected "+w+" bytes, got "+f.length);let E=r?zt(f):mt(f);if(s&&(E=k(E,e)),!h&&!I.isValid(E))throw new Error("invalid field element: outside of range 0..ORDER");return E},invertBatch:f=>te(I,f),cmov:(f,h,E)=>E?h:f});return Object.freeze(I)}function ne(e){if(typeof e!="bigint")throw new Error("field order must be bigint");const n=e.toString(2).length;return Math.ceil(n/8)}function re(e){const n=ne(e);return n+Math.ceil(n/2)}function Ie(e,n,r=!1){const t=e.length,o=ne(n),i=re(n);if(t<16||t<i||t>1024)throw new Error("expected "+i+"-1024 bytes of input, got "+t);const s=r?zt(e):mt(e),l=k(s,n-K)+K;return r?Ht(l,o):Rt(l,o)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const ot=BigInt(0),P=BigInt(1);function gt(e,n){const r=n.negate();return e?r:n}function bt(e,n){const r=te(e.Fp,n.map(t=>t.Z));return n.map((t,o)=>e.fromAffine(t.toAffine(r[o])))}function oe(e,n){if(!Number.isSafeInteger(e)||e<=0||e>n)throw new Error("invalid window size, expected [1.."+n+"], got W="+e)}function Et(e,n){oe(e,n);const r=Math.ceil(n/e)+1,t=2**(e-1),o=2**e,i=st(e),s=BigInt(e);return{windows:r,windowSize:t,mask:i,maxNumber:o,shiftBy:s}}function Yt(e,n,r){const{windowSize:t,mask:o,maxNumber:i,shiftBy:s}=r;let l=Number(e&o),a=e>>s;l>t&&(l-=i,a+=P);const w=n*t,y=w+Math.abs(l)-1,I=l===0,f=l<0,h=n%2!==0;return{nextN:a,offset:y,isZero:I,isNeg:f,isNegF:h,offsetF:w}}function qe(e,n){if(!Array.isArray(e))throw new Error("array expected");e.forEach((r,t)=>{if(!(r instanceof n))throw new Error("invalid point at index "+t)})}function Ne(e,n){if(!Array.isArray(e))throw new Error("array of scalars expected");e.forEach((r,t)=>{if(!n.isValid(r))throw new Error("invalid scalar at index "+t)})}const pt=new WeakMap,ie=new WeakMap;function Bt(e){return ie.get(e)||1}function Kt(e){if(e!==ot)throw new Error("invalid wNAF")}class Re{constructor(n,r){this.BASE=n.BASE,this.ZERO=n.ZERO,this.Fn=n.Fn,this.bits=r}_unsafeLadder(n,r,t=this.ZERO){let o=n;for(;r>ot;)r&P&&(t=t.add(o)),o=o.double(),r>>=P;return t}precomputeWindow(n,r){const{windows:t,windowSize:o}=Et(r,this.bits),i=[];let s=n,l=s;for(let a=0;a<t;a++){l=s,i.push(l);for(let w=1;w<o;w++)l=l.add(s),i.push(l);s=l.double()}return i}wNAF(n,r,t){if(!this.Fn.isValid(t))throw new Error("invalid scalar");let o=this.ZERO,i=this.BASE;const s=Et(n,this.bits);for(let l=0;l<s.windows;l++){const{nextN:a,offset:w,isZero:y,isNeg:I,isNegF:f,offsetF:h}=Yt(t,l,s);t=a,y?i=i.add(gt(f,r[h])):o=o.add(gt(I,r[w]))}return Kt(t),{p:o,f:i}}wNAFUnsafe(n,r,t,o=this.ZERO){const i=Et(n,this.bits);for(let s=0;s<i.windows&&t!==ot;s++){const{nextN:l,offset:a,isZero:w,isNeg:y}=Yt(t,s,i);if(t=l,!w){const I=r[a];o=o.add(y?I.negate():I)}}return Kt(t),o}getPrecomputes(n,r,t){let o=pt.get(r);return o||(o=this.precomputeWindow(r,n),n!==1&&(typeof t=="function"&&(o=t(o)),pt.set(r,o))),o}cached(n,r,t){const o=Bt(n);return this.wNAF(o,this.getPrecomputes(o,n,t),r)}unsafe(n,r,t,o){const i=Bt(n);return i===1?this._unsafeLadder(n,r,o):this.wNAFUnsafe(i,this.getPrecomputes(i,n,t),r,o)}createCache(n,r){oe(r,this.bits),ie.set(n,r),pt.delete(n)}hasCache(n){return Bt(n)!==1}}function Oe(e,n,r,t){let o=n,i=e.ZERO,s=e.ZERO;for(;r>ot||t>ot;)r&P&&(i=i.add(o)),t&P&&(s=s.add(o)),o=o.double(),r>>=P,t>>=P;return{p1:i,p2:s}}function Ae(e,n,r,t){qe(r,e),Ne(t,n);const o=r.length,i=t.length;if(o!==i)throw new Error("arrays of points and scalars must have equal length");const s=e.ZERO,l=Xt(BigInt(o));let a=1;l>12?a=l-3:l>4?a=l-2:l>0&&(a=2);const w=st(a),y=new Array(Number(w)+1).fill(s),I=Math.floor((n.BITS-1)/a)*a;let f=s;for(let h=I;h>=0;h-=a){y.fill(s);for(let x=0;x<i;x++){const O=t[x],U=Number(O>>BigInt(h)&w);y[U]=y[U].add(r[x])}let E=s;for(let x=y.length-1,O=s;x>0;x--)O=O.add(y[x]),E=E.add(O);if(f=f.add(E),h!==0)for(let x=0;x<a;x++)f=f.double()}return f}function Lt(e,n,r){if(n){if(n.ORDER!==e)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return xe(n),n}else return ct(e,{isLE:r})}function _e(e,n,r={},t){if(t===void 0&&(t=e==="edwards"),!n||typeof n!="object")throw new Error(`expected valid ${e} CURVE object`);for(const a of["p","n","h"]){const w=n[a];if(!(typeof w=="bigint"&&w>ot))throw new Error(`CURVE.${a} must be positive bigint`)}const o=Lt(n.p,r.Fp,t),i=Lt(n.n,r.Fn,t),l=["Gx","Gy","a","b"];for(const a of l)if(!o.isValid(n[a]))throw new Error(`CURVE.${a} must be valid field element of CURVE.Fp`);return n=Object.freeze(Object.assign({},n)),{CURVE:n,Fp:o,Fn:i}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const jt=(e,n)=>(e+(e>=0?n:-n)/se)/n;function Ze(e,n,r){const[[t,o],[i,s]]=n,l=jt(s*e,r),a=jt(-o*e,r);let w=e-l*t-a*i,y=-l*o-a*s;const I=w<H,f=y<H;I&&(w=-w),f&&(y=-y);const h=st(Math.ceil(Xt(r)/2))+rt;if(w<H||w>=h||y<H||y>=h)throw new Error("splitScalar (endomorphism): failed, k="+e);return{k1neg:I,k1:w,k2neg:f,k2:y}}function St(e){if(!["compact","recovered","der"].includes(e))throw new Error('Signature format must be "compact", "recovered", or "der"');return e}function vt(e,n){const r={};for(let t of Object.keys(n))r[t]=e[t]===void 0?n[t]:e[t];return wt(r.lowS,"lowS"),wt(r.prehash,"prehash"),r.format!==void 0&&St(r.format),r}class Ue extends Error{constructor(n=""){super(n)}}const z={Err:Ue,_tlv:{encode:(e,n)=>{const{Err:r}=z;if(e<0||e>256)throw new r("tlv.encode: wrong tag");if(n.length&1)throw new r("tlv.encode: unpadded data");const t=n.length/2,o=lt(t);if(o.length/2&128)throw new r("tlv.encode: long form length too big");const i=t>127?lt(o.length/2|128):"";return lt(e)+i+o+n},decode(e,n){const{Err:r}=z;let t=0;if(e<0||e>256)throw new r("tlv.encode: wrong tag");if(n.length<2||n[t++]!==e)throw new r("tlv.decode: wrong tlv");const o=n[t++],i=!!(o&128);let s=0;if(!i)s=o;else{const a=o&127;if(!a)throw new r("tlv.decode(long): indefinite length not supported");if(a>4)throw new r("tlv.decode(long): byte length is too big");const w=n.subarray(t,t+a);if(w.length!==a)throw new r("tlv.decode: length bytes not complete");if(w[0]===0)throw new r("tlv.decode(long): zero leftmost byte");for(const y of w)s=s<<8|y;if(t+=a,s<128)throw new r("tlv.decode(long): not minimal encoding")}const l=n.subarray(t,t+s);if(l.length!==s)throw new r("tlv.decode: wrong value length");return{v:l,l:n.subarray(t+s)}}},_int:{encode(e){const{Err:n}=z;if(e<H)throw new n("integer: negative integers are not allowed");let r=lt(e);if(Number.parseInt(r[0],16)&8&&(r="00"+r),r.length&1)throw new n("unexpected DER parsing assertion: unpadded hex");return r},decode(e){const{Err:n}=z;if(e[0]&128)throw new n("invalid signature integer: negative");if(e[0]===0&&!(e[1]&128))throw new n("invalid signature integer: unnecessary leading zero");return mt(e)}},toSig(e){const{Err:n,_int:r,_tlv:t}=z,o=j("signature",e),{v:i,l:s}=t.decode(48,o);if(s.length)throw new n("invalid signature: left bytes after parsing");const{v:l,l:a}=t.decode(2,i),{v:w,l:y}=t.decode(2,a);if(y.length)throw new n("invalid signature: left bytes after parsing");return{r:r.decode(l),s:r.decode(w)}},hexFromSig(e){const{_tlv:n,_int:r}=z,t=n.encode(2,r.encode(e.r)),o=n.encode(2,r.encode(e.s)),i=t+o;return n.encode(48,i)}},H=BigInt(0),rt=BigInt(1),se=BigInt(2),dt=BigInt(3),Te=BigInt(4);function et(e,n){const{BYTES:r}=e;let t;if(typeof n=="bigint")t=n;else{let o=j("private key",n);try{t=e.fromBytes(o)}catch{throw new Error(`invalid private key: expected ui8a of size ${r}, got ${typeof n}`)}}if(!e.isValidNot0(t))throw new Error("invalid private key: out of range [1..N-1]");return t}function Ve(e,n={}){const r=_e("weierstrass",e,n),{Fp:t,Fn:o}=r;let i=r.CURVE;const{h:s,n:l}=i;Ot(n,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});const{endo:a}=n;if(a&&(!t.is0(i.a)||typeof a.beta!="bigint"||!Array.isArray(a.basises)))throw new Error('invalid endo: expected "beta": bigint and "basises": array');const w=fe(t,o);function y(){if(!t.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function I(R,d,u){const{x:c,y:g}=d.toAffine(),m=t.toBytes(c);if(wt(u,"isCompressed"),u){y();const B=!t.isOdd(g);return D(ce(B),m)}else return D(Uint8Array.of(4),m,t.toBytes(g))}function f(R){W(R,void 0,"Point");const{publicKey:d,publicKeyUncompressed:u}=w,c=R.length,g=R[0],m=R.subarray(1);if(c===d&&(g===2||g===3)){const B=t.fromBytes(m);if(!t.isValid(B))throw new Error("bad point: is not on curve, wrong x");const p=x(B);let b;try{b=t.sqrt(p)}catch(V){const A=V instanceof Error?": "+V.message:"";throw new Error("bad point: is not on curve, sqrt error"+A)}y();const v=t.isOdd(b);return(g&1)===1!==v&&(b=t.neg(b)),{x:B,y:b}}else if(c===u&&g===4){const B=t.BYTES,p=t.fromBytes(m.subarray(0,B)),b=t.fromBytes(m.subarray(B,B*2));if(!O(p,b))throw new Error("bad point: is not on curve");return{x:p,y:b}}else throw new Error(`bad point: got length ${c}, expected compressed=${d} or uncompressed=${u}`)}const h=n.toBytes||I,E=n.fromBytes||f;function x(R){const d=t.sqr(R),u=t.mul(d,R);return t.add(t.add(u,t.mul(R,i.a)),i.b)}function O(R,d){const u=t.sqr(d),c=x(R);return t.eql(u,c)}if(!O(i.Gx,i.Gy))throw new Error("bad curve params: generator point");const U=t.mul(t.pow(i.a,dt),Te),it=t.mul(t.sqr(i.b),BigInt(27));if(t.is0(t.add(U,it)))throw new Error("bad curve params: a or b");function T(R,d,u=!1){if(!t.isValid(d)||u&&t.is0(d))throw new Error(`bad point coordinate ${R}`);return d}function G(R){if(!(R instanceof q))throw new Error("ProjectivePoint expected")}function X(R){if(!a||!a.basises)throw new Error("no endo");return Ze(R,a.basises,o.ORDER)}const J=Tt((R,d)=>{const{X:u,Y:c,Z:g}=R;if(t.eql(g,t.ONE))return{x:u,y:c};const m=R.is0();d==null&&(d=m?t.ONE:t.inv(g));const B=t.mul(u,d),p=t.mul(c,d),b=t.mul(g,d);if(m)return{x:t.ZERO,y:t.ZERO};if(!t.eql(b,t.ONE))throw new Error("invZ was invalid");return{x:B,y:p}}),ft=Tt(R=>{if(R.is0()){if(n.allowInfinityPoint&&!t.is0(R.Y))return;throw new Error("bad point: ZERO")}const{x:d,y:u}=R.toAffine();if(!t.isValid(d)||!t.isValid(u))throw new Error("bad point: x or y not field elements");if(!O(d,u))throw new Error("bad point: equation left != right");if(!R.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function tt(R,d,u,c,g){return u=new q(t.mul(u.X,R),u.Y,u.Z),d=gt(c,d),u=gt(g,u),d.add(u)}class q{constructor(d,u,c){this.X=T("x",d),this.Y=T("y",u,!0),this.Z=T("z",c),Object.freeze(this)}static CURVE(){return i}static fromAffine(d){const{x:u,y:c}=d||{};if(!d||!t.isValid(u)||!t.isValid(c))throw new Error("invalid affine point");if(d instanceof q)throw new Error("projective point not allowed");return t.is0(u)&&t.is0(c)?q.ZERO:new q(u,c,t.ONE)}static fromBytes(d){const u=q.fromAffine(E(W(d,void 0,"point")));return u.assertValidity(),u}static fromHex(d){return q.fromBytes(j("pointHex",d))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(d=8,u=!0){return F.createCache(this,d),u||this.multiply(dt),this}assertValidity(){ft(this)}hasEvenY(){const{y:d}=this.toAffine();if(!t.isOdd)throw new Error("Field doesn't support isOdd");return!t.isOdd(d)}equals(d){G(d);const{X:u,Y:c,Z:g}=this,{X:m,Y:B,Z:p}=d,b=t.eql(t.mul(u,p),t.mul(m,g)),v=t.eql(t.mul(c,p),t.mul(B,g));return b&&v}negate(){return new q(this.X,t.neg(this.Y),this.Z)}double(){const{a:d,b:u}=i,c=t.mul(u,dt),{X:g,Y:m,Z:B}=this;let p=t.ZERO,b=t.ZERO,v=t.ZERO,S=t.mul(g,g),V=t.mul(m,m),A=t.mul(B,B),N=t.mul(g,m);return N=t.add(N,N),v=t.mul(g,B),v=t.add(v,v),p=t.mul(d,v),b=t.mul(c,A),b=t.add(p,b),p=t.sub(V,b),b=t.add(V,b),b=t.mul(p,b),p=t.mul(N,p),v=t.mul(c,v),A=t.mul(d,A),N=t.sub(S,A),N=t.mul(d,N),N=t.add(N,v),v=t.add(S,S),S=t.add(v,S),S=t.add(S,A),S=t.mul(S,N),b=t.add(b,S),A=t.mul(m,B),A=t.add(A,A),S=t.mul(A,N),p=t.sub(p,S),v=t.mul(A,V),v=t.add(v,v),v=t.add(v,v),new q(p,b,v)}add(d){G(d);const{X:u,Y:c,Z:g}=this,{X:m,Y:B,Z:p}=d;let b=t.ZERO,v=t.ZERO,S=t.ZERO;const V=i.a,A=t.mul(i.b,dt);let N=t.mul(u,m),_=t.mul(c,B),$=t.mul(g,p),L=t.add(u,c),Z=t.add(m,B);L=t.mul(L,Z),Z=t.add(N,_),L=t.sub(L,Z),Z=t.add(u,g);let Y=t.add(m,p);return Z=t.mul(Z,Y),Y=t.add(N,$),Z=t.sub(Z,Y),Y=t.add(c,g),b=t.add(B,p),Y=t.mul(Y,b),b=t.add(_,$),Y=t.sub(Y,b),S=t.mul(V,Z),b=t.mul(A,$),S=t.add(b,S),b=t.sub(_,S),S=t.add(_,S),v=t.mul(b,S),_=t.add(N,N),_=t.add(_,N),$=t.mul(V,$),Z=t.mul(A,Z),_=t.add(_,$),$=t.sub(N,$),$=t.mul(V,$),Z=t.add(Z,$),N=t.mul(_,Z),v=t.add(v,N),N=t.mul(Y,Z),b=t.mul(L,b),b=t.sub(b,N),N=t.mul(L,_),S=t.mul(Y,S),S=t.add(S,N),new q(b,v,S)}subtract(d){return this.add(d.negate())}is0(){return this.equals(q.ZERO)}multiply(d){const{endo:u}=n;if(!o.isValidNot0(d))throw new Error("invalid scalar: out of range");let c,g;const m=B=>F.cached(this,B,p=>bt(q,p));if(u){const{k1neg:B,k1:p,k2neg:b,k2:v}=X(d),{p:S,f:V}=m(p),{p:A,f:N}=m(v);g=V.add(N),c=tt(u.beta,S,A,B,b)}else{const{p:B,f:p}=m(d);c=B,g=p}return bt(q,[c,g])[0]}multiplyUnsafe(d){const{endo:u}=n,c=this;if(!o.isValid(d))throw new Error("invalid scalar: out of range");if(d===H||c.is0())return q.ZERO;if(d===rt)return c;if(F.hasCache(this))return this.multiply(d);if(u){const{k1neg:g,k1:m,k2neg:B,k2:p}=X(d),{p1:b,p2:v}=Oe(q,c,m,p);return tt(u.beta,b,v,g,B)}else return F.unsafe(c,d)}multiplyAndAddUnsafe(d,u,c){const g=this.multiplyUnsafe(u).add(d.multiplyUnsafe(c));return g.is0()?void 0:g}toAffine(d){return J(this,d)}isTorsionFree(){const{isTorsionFree:d}=n;return s===rt?!0:d?d(q,this):F.unsafe(this,l).is0()}clearCofactor(){const{clearCofactor:d}=n;return s===rt?this:d?d(q,this):this.multiplyUnsafe(s)}isSmallOrder(){return this.multiplyUnsafe(s).is0()}toBytes(d=!0){return wt(d,"isCompressed"),this.assertValidity(),h(q,this,d)}toHex(d=!0){return nt(this.toBytes(d))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get px(){return this.X}get py(){return this.X}get pz(){return this.Z}toRawBytes(d=!0){return this.toBytes(d)}_setWindowSize(d){this.precompute(d)}static normalizeZ(d){return bt(q,d)}static msm(d,u){return Ae(q,o,d,u)}static fromPrivateKey(d){return q.BASE.multiply(et(o,d))}}q.BASE=new q(i.Gx,i.Gy,t.ONE),q.ZERO=new q(t.ZERO,t.ONE,t.ZERO),q.Fp=t,q.Fn=o;const ut=o.BITS,F=new Re(q,n.endo?Math.ceil(ut/2):ut);return q.BASE.precompute(8),q}function ce(e){return Uint8Array.of(e?2:3)}function fe(e,n){return{secretKey:n.BYTES,publicKey:1+e.BYTES,publicKeyUncompressed:1+2*e.BYTES,publicKeyHasPrefix:!0,signature:2*n.BYTES}}function $e(e,n={}){const{Fn:r}=e,t=n.randomBytes||Ct,o=Object.assign(fe(e.Fp,r),{seed:re(r.ORDER)});function i(h){try{return!!et(r,h)}catch{return!1}}function s(h,E){const{publicKey:x,publicKeyUncompressed:O}=o;try{const U=h.length;return E===!0&&U!==x||E===!1&&U!==O?!1:!!e.fromBytes(h)}catch{return!1}}function l(h=t(o.seed)){return Ie(W(h,o.seed,"seed"),r.ORDER)}function a(h,E=!0){return e.BASE.multiply(et(r,h)).toBytes(E)}function w(h){const E=l(h);return{secretKey:E,publicKey:a(E)}}function y(h){if(typeof h=="bigint")return!1;if(h instanceof e)return!0;const{secretKey:E,publicKey:x,publicKeyUncompressed:O}=o;if(r.allowedLengths||E===x)return;const U=j("key",h).length;return U===x||U===O}function I(h,E,x=!0){if(y(h)===!0)throw new Error("first arg must be private key");if(y(E)===!1)throw new Error("second arg must be public key");const O=et(r,h);return e.fromHex(E).multiply(O).toBytes(x)}return Object.freeze({getPublicKey:a,getSharedSecret:I,keygen:w,Point:e,utils:{isValidSecretKey:i,isValidPublicKey:s,randomSecretKey:l,isValidPrivateKey:i,randomPrivateKey:l,normPrivateKeyToScalar:h=>et(r,h),precompute(h=8,E=e.BASE){return E.precompute(h,!1)}},lengths:o})}function Ye(e,n,r={}){le(n),Ot(r,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const t=r.randomBytes||Ct,o=r.hmac||((u,...c)=>he(n,u,D(...c))),{Fp:i,Fn:s}=e,{ORDER:l,BITS:a}=s,{keygen:w,getPublicKey:y,getSharedSecret:I,utils:f,lengths:h}=$e(e,r),E={prehash:!1,lowS:typeof r.lowS=="boolean"?r.lowS:!1,format:void 0,extraEntropy:!1},x="compact";function O(u){const c=l>>rt;return u>c}function U(u,c){if(!s.isValidNot0(c))throw new Error(`invalid signature ${u}: out of range 1..Point.Fn.ORDER`);return c}function it(u,c){St(c);const g=h.signature,m=c==="compact"?g:c==="recovered"?g+1:void 0;return W(u,m,`${c} signature`)}class T{constructor(c,g,m){this.r=U("r",c),this.s=U("s",g),m!=null&&(this.recovery=m),Object.freeze(this)}static fromBytes(c,g=x){it(c,g);let m;if(g==="der"){const{r:v,s:S}=z.toSig(W(c));return new T(v,S)}g==="recovered"&&(m=c[0],g="compact",c=c.subarray(1));const B=s.BYTES,p=c.subarray(0,B),b=c.subarray(B,B*2);return new T(s.fromBytes(p),s.fromBytes(b),m)}static fromHex(c,g){return this.fromBytes(ht(c),g)}addRecoveryBit(c){return new T(this.r,this.s,c)}recoverPublicKey(c){const g=i.ORDER,{r:m,s:B,recovery:p}=this;if(p==null||![0,1,2,3].includes(p))throw new Error("recovery id invalid");if(l*se<g&&p>1)throw new Error("recovery id is ambiguous for h>1 curve");const v=p===2||p===3?m+l:m;if(!i.isValid(v))throw new Error("recovery id 2 or 3 invalid");const S=i.toBytes(v),V=e.fromBytes(D(ce((p&1)===0),S)),A=s.inv(v),N=X(j("msgHash",c)),_=s.create(-N*A),$=s.create(B*A),L=e.BASE.multiplyUnsafe(_).add(V.multiplyUnsafe($));if(L.is0())throw new Error("point at infinify");return L.assertValidity(),L}hasHighS(){return O(this.s)}toBytes(c=x){if(St(c),c==="der")return ht(z.hexFromSig(this));const g=s.toBytes(this.r),m=s.toBytes(this.s);if(c==="recovered"){if(this.recovery==null)throw new Error("recovery bit must be present");return D(Uint8Array.of(this.recovery),g,m)}return D(g,m)}toHex(c){return nt(this.toBytes(c))}assertValidity(){}static fromCompact(c){return T.fromBytes(j("sig",c),"compact")}static fromDER(c){return T.fromBytes(j("sig",c),"der")}normalizeS(){return this.hasHighS()?new T(this.r,s.neg(this.s),this.recovery):this}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return nt(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return nt(this.toBytes("compact"))}}const G=r.bits2int||function(c){if(c.length>8192)throw new Error("input is too large");const g=mt(c),m=c.length*8-a;return m>0?g>>BigInt(m):g},X=r.bits2int_modN||function(c){return s.create(G(c))},J=st(a);function ft(u){return ge("num < 2^"+a,u,H,J),s.toBytes(u)}function tt(u,c){return W(u,void 0,"message"),c?W(n(u),void 0,"prehashed message"):u}function q(u,c,g){if(["recovered","canonical"].some(_=>_ in g))throw new Error("sign() legacy options not supported");const{lowS:m,prehash:B,extraEntropy:p}=vt(g,E);u=tt(u,B);const b=X(u),v=et(s,c),S=[ft(v),ft(b)];if(p!=null&&p!==!1){const _=p===!0?t(h.secretKey):p;S.push(j("extraEntropy",_))}const V=D(...S),A=b;function N(_){const $=G(_);if(!s.isValidNot0($))return;const L=s.inv($),Z=e.BASE.multiply($).toAffine(),Y=s.create(Z.x);if(Y===H)return;const at=s.create(L*s.create(A+Y*v));if(at===H)return;let Zt=(Z.x===Y?0:2)|Number(Z.y&rt),Ut=at;return m&&O(at)&&(Ut=s.neg(at),Zt^=1),new T(Y,Ut,Zt)}return{seed:V,k2sig:N}}function ut(u,c,g={}){u=j("message",u);const{seed:m,k2sig:B}=q(u,c,g);return me(n.outputLen,s.BYTES,o)(m,B)}function F(u){let c;const g=typeof u=="string"||qt(u),m=!g&&u!==null&&typeof u=="object"&&typeof u.r=="bigint"&&typeof u.s=="bigint";if(!g&&!m)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");if(m)c=new T(u.r,u.s);else if(g){try{c=T.fromBytes(j("sig",u),"der")}catch(B){if(!(B instanceof z.Err))throw B}if(!c)try{c=T.fromBytes(j("sig",u),"compact")}catch{return!1}}return c||!1}function R(u,c,g,m={}){const{lowS:B,prehash:p,format:b}=vt(m,E);if(g=j("publicKey",g),c=tt(j("message",c),p),"strict"in m)throw new Error("options.strict was renamed to lowS");const v=b===void 0?F(u):T.fromBytes(j("sig",u),b);if(v===!1)return!1;try{const S=e.fromBytes(g);if(B&&v.hasHighS())return!1;const{r:V,s:A}=v,N=X(c),_=s.inv(A),$=s.create(N*_),L=s.create(V*_),Z=e.BASE.multiplyUnsafe($).add(S.multiplyUnsafe(L));return Z.is0()?!1:s.create(Z.x)===V}catch{return!1}}function d(u,c,g={}){const{prehash:m}=vt(g,E);return c=tt(c,m),T.fromBytes(u,"recovered").recoverPublicKey(c).toBytes()}return Object.freeze({keygen:w,getPublicKey:y,getSharedSecret:I,utils:f,lengths:h,Point:e,sign:ut,verify:R,recoverPublicKey:d,Signature:T,hash:n})}function Ke(e){const n={a:e.a,b:e.b,p:e.Fp.ORDER,n:e.n,h:e.h,Gx:e.Gx,Gy:e.Gy},r=e.Fp;let t=e.allowedPrivateKeyLengths?Array.from(new Set(e.allowedPrivateKeyLengths.map(s=>Math.ceil(s/2)))):void 0;const o=ct(n.n,{BITS:e.nBitLength,allowedLengths:t,modFromBytes:e.wrapPrivateKey}),i={Fp:r,Fn:o,allowInfinityPoint:e.allowInfinityPoint,endo:e.endo,isTorsionFree:e.isTorsionFree,clearCofactor:e.clearCofactor,fromBytes:e.fromBytes,toBytes:e.toBytes};return{CURVE:n,curveOpts:i}}function Le(e){const{CURVE:n,curveOpts:r}=Ke(e),t={hmac:e.hmac,randomBytes:e.randomBytes,lowS:e.lowS,bits2int:e.bits2int,bits2int_modN:e.bits2int_modN};return{CURVE:n,curveOpts:r,hash:e.hash,ecdsaOpts:t}}function je(e,n){const r=n.Point;return Object.assign({},n,{ProjectivePoint:r,CURVE:Object.assign({},e,ee(r.Fn.ORDER,r.Fn.BITS))})}function Me(e){const{CURVE:n,curveOpts:r,hash:t,ecdsaOpts:o}=Le(e),i=Ve(n,r),s=Ye(i,t,o);return je(e,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Ce(e,n){const r=t=>Me({...e,hash:t});return{...r(n),create:r}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const _t={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},ke={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},Mt=BigInt(2);function ze(e){const n=_t.p,r=BigInt(3),t=BigInt(6),o=BigInt(11),i=BigInt(22),s=BigInt(23),l=BigInt(44),a=BigInt(88),w=e*e*e%n,y=w*w*e%n,I=C(y,r,n)*y%n,f=C(I,r,n)*y%n,h=C(f,Mt,n)*w%n,E=C(h,o,n)*h%n,x=C(E,i,n)*E%n,O=C(x,l,n)*x%n,U=C(O,a,n)*O%n,it=C(U,l,n)*x%n,T=C(it,r,n)*y%n,G=C(T,s,n)*E%n,X=C(G,t,n)*w%n,J=C(X,Mt,n);if(!It.eql(It.sqr(J),e))throw new Error("Cannot find square root");return J}const It=ct(_t.p,{sqrt:ze}),De=Ce({..._t,Fp:It,lowS:!0,endo:ke},de);export{De as secp256k1};
