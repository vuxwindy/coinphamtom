import{K as p,ac as y,as as c}from"./index-r-K8bCt4.js";import{readContract as w}from"./read-contract-DpACvx2n.js";import"./utils-GbVwyc3t.js";import"./to-serializable-transaction-BMbNRj8d.js";async function u({account:e,serializableTransaction:a,transaction:n,gasless:s}){const t=c({address:s.relayerForwarderAddress,chain:n.chain,client:n.client}),r=await w({contract:t,method:"function getNonce(address) view returns (uint256)",params:[e.address]}),[o,m]=await(async()=>{if(!a.to)throw new Error("OpenZeppelin transactions must have a 'to' address");if(!a.gas)throw new Error("OpenZeppelin transactions must have a 'gas' value");if(!a.data)throw new Error("OpenZeppelin transactions must have a 'data' value");if(s.experimentalChainlessSupport){const i={chainid:BigInt(n.chain.id),data:a.data,from:e.address,gas:a.gas,nonce:r,to:a.to,value:0n};return[await e.signTypedData({domain:{name:"GSNv2 Forwarder",verifyingContract:t.address,version:"0.0.1"},message:i,primaryType:"ForwardRequest",types:{ForwardRequest:h}}),i]}const d={data:a.data,from:e.address,gas:a.gas,nonce:r,to:a.to,value:0n};return[await e.signTypedData({domain:{chainId:n.chain.id,name:s.domainName??"GSNv2 Forwarder",verifyingContract:t.address,version:s.domainVersion??"0.0.1"},message:d,primaryType:"ForwardRequest",types:{ForwardRequest:g}}),d]})();return{message:m,messageType:"forward",signature:o}}const g=[{name:"from",type:"address"},{name:"to",type:"address"},{name:"value",type:"uint256"},{name:"gas",type:"uint256"},{name:"nonce",type:"uint256"},{name:"data",type:"bytes"}],h=[{name:"from",type:"address"},{name:"to",type:"address"},{name:"value",type:"uint256"},{name:"gas",type:"uint256"},{name:"nonce",type:"uint256"},{name:"data",type:"bytes"},{name:"chainid",type:"uint256"}];async function O(e){const{message:a,messageType:n,signature:s}=await u(e),t=await fetch(e.gasless.relayerUrl,{body:p({forwarderAddress:e.gasless.relayerForwarderAddress,request:a,signature:s,type:n}),method:"POST"});if(!t.ok)throw new Error(`Failed to send transaction: ${await t.text()}`);const r=await t.json();if(!r.result)throw new Error(`Relay transaction failed: ${r.message}`);const o=JSON.parse(r.result).txHash;if(y(o))return{chain:e.transaction.chain,client:e.transaction.client,transactionHash:o};throw new Error(`Failed to send transaction: ${p(r)}`)}export{u as prepareOpenZeppelinTransaction,O as relayOpenZeppelinTransaction};
