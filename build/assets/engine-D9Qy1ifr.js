import{K as w,as as p}from"./index-r-K8bCt4.js";import{readContract as y}from"./read-contract-DpACvx2n.js";import{w as h}from"./wait-for-tx-receipt-C9zxAqk4.js";import"./utils-GbVwyc3t.js";import"./to-serializable-transaction-BMbNRj8d.js";import"./sleep-mAKpSMLY.js";async function f({account:t,serializableTransaction:e,transaction:r,gasless:n}){const a=p({address:n.relayerForwarderAddress,chain:r.chain,client:r.client}),s=await y({contract:a,method:"function getNonce(address) view returns (uint256)",params:[t.address]}),[o,i]=await(async()=>{if(!e.to)throw new Error("engine transactions must have a 'to' address");if(!e.gas)throw new Error("engine transactions must have a 'gas' value");if(!e.data)throw new Error("engine transactions must have a 'data' value");if(n.experimentalChainlessSupport){const d={chainid:BigInt(r.chain.id),data:e.data,from:t.address,gas:e.gas,nonce:s,to:e.to,value:0n};return[await t.signTypedData({domain:{name:"GSNv2 Forwarder",verifyingContract:a.address,version:"0.0.1"},message:d,primaryType:"ForwardRequest",types:{ForwardRequest:l}}),d]}const c={data:e.data,from:t.address,gas:e.gas,nonce:s,to:e.to,value:0n};return[await t.signTypedData({domain:{chainId:r.chain.id,name:n.domainName??"GSNv2 Forwarder",verifyingContract:a.address,version:n.domainVersion??"0.0.1"},message:c,primaryType:"ForwardRequest",types:{ForwardRequest:g}}),c]})();return{message:i,messageType:"forward",signature:o}}const g=[{name:"from",type:"address"},{name:"to",type:"address"},{name:"value",type:"uint256"},{name:"gas",type:"uint256"},{name:"nonce",type:"uint256"},{name:"data",type:"bytes"}],l=[{name:"from",type:"address"},{name:"to",type:"address"},{name:"value",type:"uint256"},{name:"gas",type:"uint256"},{name:"nonce",type:"uint256"},{name:"data",type:"bytes"},{name:"chainid",type:"uint256"}];async function $(t){const{message:e,messageType:r,signature:n}=await f(t),a=await fetch(t.gasless.relayerUrl,{body:w({forwarderAddress:t.gasless.relayerForwarderAddress,request:e,signature:n,type:r}),headers:{"Content-Type":"application/json"},method:"POST"});if(!a.ok)throw new Error(`Failed to send transaction: ${await a.text()}`);const s=await a.json();if(!s.result)throw new Error(`Relay transaction failed: ${s.message}`);const o=s.result.queueId,i=6e4,m=1e3,c=Date.now()+i;for(;Date.now()<c;){const d=await v({options:t,queueId:o});if(d)return{chain:t.transaction.chain,client:t.transaction.client,transactionHash:d.transactionHash};await new Promise(u=>setTimeout(u,m))}throw new Error(`Failed to find relayed transaction after ${i}ms`)}async function v(t){const{options:e,queueId:r}=t,n=e.gasless.relayerUrl.split("/relayer/")[0],a=await fetch(`${n}/transaction/status/${r}`,{method:"GET"}),s=await a.json();if(!a.ok)return null;const o=s.result;if(!o)return null;switch(o.status){case"errored":throw new Error(`Transaction errored with reason: ${o.errorMessage}`);case"cancelled":throw new Error("Transaction execution cancelled.");case"mined":return await h({chain:e.transaction.chain,client:e.transaction.client,transactionHash:o.transactionHash});default:return null}}export{f as prepareEngineTransaction,$ as relayEngineTransaction};
