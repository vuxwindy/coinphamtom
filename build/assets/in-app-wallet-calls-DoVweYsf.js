import{w as m,e as p}from"./wait-for-tx-receipt-C9zxAqk4.js";import{ao as w,ap as h,bo as f,aa as T}from"./index-r-K8bCt4.js";import{s as b}from"./send-transaction-DRs_bS9h.js";import{r as g}from"./random-Dc3txyW0.js";import"./to-serializable-transaction-BMbNRj8d.js";import"./sleep-mAKpSMLY.js";async function H(c){const t=await b(c);return m(t)}async function y(c){const{account:t,transactions:o}=c;if(!t)throw new Error("not connected");if(o.length===0)throw new Error("No transactions to send");const s=o[0];if(!s)throw new Error("No transactions to send");if(t.sendBatchTransaction){const n=await Promise.all(o.map(async a=>{const[u,i,e,l]=await Promise.all([w(a),h(a.to),h(a.accessList),h(a.value)]);return{accessList:e,chainId:a.chain.id,data:u,to:i,value:l}}));return{...await t.sendBatchTransaction(n),chain:s.chain,client:s.client}}throw new Error("Account doesn't implement sendBatchTransaction")}const d=new f(1e3);async function N(c){const{account:t,calls:o}=c,s=[],n=g(65);if(d.set(n,s),t.sendBatchTransaction){const r=await y({account:t,transactions:o});s.push(r.transactionHash),d.set(n,s)}else for(const r of o){const a=await H({account:t,transaction:r});s.push(a.transactionHash),d.set(n,s)}return n}async function P(c){const{chain:t,client:o,id:s}=c,n=d.get(s);if(!n)throw new Error("Failed to get calls status, unknown bundle id");const r=T({chain:t,client:o});let a="success";const u=await Promise.all(n.map(i=>p(r,{hash:i}).then(e=>({blockHash:e.blockHash,blockNumber:e.blockNumber,gasUsed:e.gasUsed,logs:e.logs.map(l=>({address:l.address,data:l.data,topics:l.topics})),status:e.status,transactionHash:e.transactionHash})).catch(()=>(a="pending",null))));return{atomic:!1,chainId:t.id,id:s,receipts:u.filter(i=>i!==null),status:a,statusCode:200,version:"2.0.0"}}export{P as inAppWalletGetCallsStatus,N as inAppWalletSendCalls};
