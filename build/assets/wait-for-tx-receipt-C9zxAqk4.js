import{aU as T,am as _,aa as x}from"./index-r-K8bCt4.js";import{m as A}from"./to-serializable-transaction-BMbNRj8d.js";import{s as L}from"./sleep-mAKpSMLY.js";function y(e,{args:t,eventName:n}={}){return{...e,blockHash:e.blockHash?e.blockHash:null,blockNumber:e.blockNumber?BigInt(e.blockNumber):null,logIndex:e.logIndex?Number(e.logIndex):null,transactionHash:e.transactionHash?e.transactionHash:null,transactionIndex:e.transactionIndex?Number(e.transactionIndex):null,...n?{args:t,eventName:n}:{}}}const P={"0x0":"reverted","0x1":"success"};function G(e){const t={...e,blockNumber:e.blockNumber?BigInt(e.blockNumber):null,contractAddress:e.contractAddress?e.contractAddress:null,cumulativeGasUsed:e.cumulativeGasUsed?BigInt(e.cumulativeGasUsed):null,effectiveGasPrice:e.effectiveGasPrice?BigInt(e.effectiveGasPrice):null,gasUsed:e.gasUsed?BigInt(e.gasUsed):null,logs:e.logs?e.logs.map(n=>y(n)):null,to:e.to?e.to:null,transactionIndex:e.transactionIndex?T(e.transactionIndex):null,status:e.status?P[e.status]:null,type:e.type?A[e.type]||e.type:null};return e.blobGasPrice&&(t.blobGasPrice=BigInt(e.blobGasPrice)),e.blobGasUsed&&(t.blobGasUsed=BigInt(e.blobGasUsed)),t}async function U(e){const t=await e({method:"eth_blockNumber"});return _(t)}async function E(e,t){const n=await e({method:"eth_getTransactionReceipt",params:[t.hash]});if(!n)throw new Error("Transaction receipt not found.");return G(n)}const p=5e3,D=1e3,N=500,v=2,B=10;function H(e){for(;e.length<B;)e.unshift(D);return e.reduce((n,c)=>n+c,0)/e.length}function M(e,t,n,c){let a=[],o=[],u=!1,s,r;const h=x({chain:t,client:e});async function d(){if(!u)return;try{const l=await U(h);if(!s||l>s){let m=[];if(s)for(let b=s+1n;b<=l;b++)m.push(BigInt(b));else m=[l];s=l;const k=Date.now();if(r){const b=(k-r)/m.length;o.push(b),o=o.slice(-B)}r=k;for(const b of m)for(const g of a)g(b)}}catch(l){c?c(l):console.error(`[watchBlockNumber]: Failed to poll for latest block number: ${l}`)}const f=H(o),i=Math.max(N,Math.min(p,Math.max(N,f)));await L(i/(n??v)),d()}return function(i,l){return a.push(i),u||(s=l,u=!0,d()),function(){a=a.filter(k=>k!==i),a.length===0&&(s=void 0,r=void 0,u=!1)}}}const w=new Map;function O(e){const{client:t,chain:n,onNewBlockNumber:c,overPollRatio:a,latestBlockNumber:o,onError:u}=e,s=n.id;let r=w.get(s);return r||(r=M(t,n,a,u),w.set(s,r)),r(c,o)}const W=100,I=new Map;function C(e){const{transactionHash:t,chain:n,client:c}=e,o=`${n.id}:tx_${t}`,u=e.maxBlocksWaitTime??W;if(I.has(o))return I.get(o);const s=new Promise((r,h)=>{t||h(new Error("Transaction has no transactionHash to wait for, did you execute it?"));const d=x({chain:n,client:c});let f=-1;const i=O({chain:n,client:c,onNewBlockNumber:async()=>{if(f++,f>=u){i(),h(new Error(`Transaction receipt for ${t} not found after ${u} blocks`));return}try{const l=await E(d,{hash:t});i(),r(l)}catch{}}})}).finally(()=>{I.delete(o)});return I.set(o,s),s}export{E as e,C as w};
