// Database Validator and Fixer
// Ki·ªÉm tra v√† s·ª≠a l·ªói database

console.log('üîç Database Validator loaded')

export class DatabaseValidator {
  constructor() {
    this.errors = []
    this.fixes = []
  }

  // Ki·ªÉm tra c·∫•u tr√∫c database
  async validateDatabaseStructure() {
    console.log('üîç Validating database structure...')
    
    try {
      // Ki·ªÉm tra Firebase connection
      const firebaseCheck = await this.checkFirebaseConnection()
      if (!firebaseCheck.success) {
        this.errors.push('Firebase connection failed')
        return false
      }

      // Ki·ªÉm tra collections
      const collectionsCheck = await this.checkCollections()
      if (!collectionsCheck.success) {
        this.errors.push('Collections check failed')
        return false
      }

      // Ki·ªÉm tra user data structure
      const userDataCheck = await this.checkUserDataStructure()
      if (!userDataCheck.success) {
        this.errors.push('User data structure check failed')
        return false
      }

      console.log('‚úÖ Database structure validation completed')
      return true
    } catch (error) {
      console.error('‚ùå Database validation failed:', error)
      this.errors.push(error.message)
      return false
    }
  }

  // Ki·ªÉm tra k·∫øt n·ªëi Firebase
  async checkFirebaseConnection() {
    try {
      // Ki·ªÉm tra xem Firebase ƒë√£ ƒë∆∞·ª£c kh·ªüi t·∫°o ch∆∞a
      if (typeof window !== 'undefined' && window.firebase) {
        console.log('‚úÖ Firebase connection found')
        return { success: true }
      } else {
        console.warn('‚ö†Ô∏è Firebase not found, checking for Vue Firebase...')
        // Ki·ªÉm tra Vue Firebase
        const { app } = await import('../config/firebase.js')
        if (app) {
          console.log('‚úÖ Vue Firebase connection found')
          return { success: true }
        } else {
          return { success: false, error: 'No Firebase connection found' }
        }
      }
    } catch (error) {
      console.error('‚ùå Firebase connection check failed:', error)
      return { success: false, error: error.message }
    }
  }

  // Ki·ªÉm tra collections
  async checkCollections() {
    try {
      const requiredCollections = [
        'users',
        'daily_tasks',
        'referrals',
        'transactions',
        'nfts'
      ]

      console.log('üìã Checking required collections...')
      
      // Trong m√¥i tr∆∞·ªùng development, ch√∫ng ta s·∫Ω t·∫°o collections n·∫øu ch∆∞a c√≥
      for (const collection of requiredCollections) {
        console.log(`üìÅ Checking collection: ${collection}`)
        // Collections s·∫Ω ƒë∆∞·ª£c t·∫°o t·ª± ƒë·ªông khi c√≥ d·ªØ li·ªáu ƒë·∫ßu ti√™n
      }

      return { success: true }
    } catch (error) {
      console.error('‚ùå Collections check failed:', error)
      return { success: false, error: error.message }
    }
  }

  // Ki·ªÉm tra c·∫•u tr√∫c user data
  async checkUserDataStructure() {
    try {
      console.log('üë§ Checking user data structure...')
      
      const requiredFields = [
        'uid',
        'email',
        'displayName',
        'tokenBalance',
        'nftBalance',
        'totalEarned',
        'referralEarnings',
        'referralCode',
        'referralCount',
        'level',
        'dailyTasks',
        'completedTasks',
        'createdAt',
        'updatedAt'
      ]

      console.log('üìã Required user fields:', requiredFields)
      
      // Trong m√¥i tr∆∞·ªùng development, ch√∫ng ta s·∫Ω t·∫°o default values
      const defaultUserData = {
        uid: '',
        email: '',
        displayName: '',
        tokenBalance: 0,
        nftBalance: 0,
        totalEarned: 0,
        referralEarnings: 0,
        referralCode: '',
        referralCount: 0,
        level: 'F0',
        dailyTasks: {
          checkIn: false,
          telegramGroup: false,
          telegramChannel: false,
          facebookPage: false,
          twitterFollow: false,
          socialShare: false
        },
        completedTasks: [],
        createdAt: new Date(),
        updatedAt: new Date()
      }

      console.log('üìã Default user data structure:', defaultUserData)
      
      return { success: true, defaultUserData }
    } catch (error) {
      console.error('‚ùå User data structure check failed:', error)
      return { success: false, error: error.message }
    }
  }

  // S·ª≠a l·ªói database
  async fixDatabaseIssues() {
    console.log('üîß Fixing database issues...')
    
    try {
      const fixes = []

      // S·ª≠a l·ªói user data
      const userDataFix = await this.fixUserData()
      if (userDataFix.success) {
        fixes.push('User data fixed')
      }

      // S·ª≠a l·ªói task data
      const taskDataFix = await this.fixTaskData()
      if (taskDataFix.success) {
        fixes.push('Task data fixed')
      }

      // S·ª≠a l·ªói referral data
      const referralDataFix = await this.fixReferralData()
      if (referralDataFix.success) {
        fixes.push('Referral data fixed')
      }

      this.fixes = fixes
      console.log('‚úÖ Database fixes completed:', fixes)
      return { success: true, fixes }
    } catch (error) {
      console.error('‚ùå Database fixes failed:', error)
      return { success: false, error: error.message }
    }
  }

  // S·ª≠a l·ªói user data
  async fixUserData() {
    try {
      console.log('üë§ Fixing user data...')
      
      // Ki·ªÉm tra localStorage
      const localUserData = localStorage.getItem('userData')
      if (localUserData) {
        const userData = JSON.parse(localUserData)
        
        // Th√™m c√°c tr∆∞·ªùng c√≤n thi·∫øu
        const fixedUserData = {
          ...userData,
          tokenBalance: userData.tokenBalance || 0,
          nftBalance: userData.nftBalance || 0,
          totalEarned: userData.totalEarned || 0,
          referralEarnings: userData.referralEarnings || 0,
          referralCode: userData.referralCode || '',
          referralCount: userData.referralCount || 0,
          level: userData.level || 'F0',
          dailyTasks: userData.dailyTasks || {
            checkIn: false,
            telegramGroup: false,
            telegramChannel: false,
            facebookPage: false,
            twitterFollow: false,
            socialShare: false
          },
          completedTasks: userData.completedTasks || [],
          updatedAt: new Date()
        }
        
        localStorage.setItem('userData', JSON.stringify(fixedUserData))
        console.log('‚úÖ User data fixed in localStorage')
      }

      return { success: true }
    } catch (error) {
      console.error('‚ùå User data fix failed:', error)
      return { success: false, error: error.message }
    }
  }

  // S·ª≠a l·ªói task data
  async fixTaskData() {
    try {
      console.log('üìã Fixing task data...')
      
      // Ki·ªÉm tra localStorage
      const localTaskData = localStorage.getItem('dailyTasks')
      if (localTaskData) {
        const taskData = JSON.parse(localTaskData)
        
        // ƒê·∫£m b·∫£o t·∫•t c·∫£ tasks ƒë·ªÅu c√≥ ƒë·∫ßy ƒë·ªß th√¥ng tin
        const requiredTasks = [
          'checkIn',
          'telegramGroup',
          'telegramChannel',
          'facebookPage',
          'twitterFollow',
          'socialShare'
        ]
        
        const fixedTaskData = {}
        requiredTasks.forEach(taskId => {
          if (taskData[taskId]) {
            fixedTaskData[taskId] = {
              ...taskData[taskId],
              completed: taskData[taskId].completed || false,
              lastCompleted: taskData[taskId].lastCompleted || null
            }
          } else {
            fixedTaskData[taskId] = {
              completed: false,
              lastCompleted: null
            }
          }
        })
        
        localStorage.setItem('dailyTasks', JSON.stringify(fixedTaskData))
        console.log('‚úÖ Task data fixed in localStorage')
      }

      return { success: true }
    } catch (error) {
      console.error('‚ùå Task data fix failed:', error)
      return { success: false, error: error.message }
    }
  }

  // S·ª≠a l·ªói referral data
  async fixReferralData() {
    try {
      console.log('üîó Fixing referral data...')
      
      // Ki·ªÉm tra localStorage
      const localReferralData = localStorage.getItem('referralData')
      if (localReferralData) {
        const referralData = JSON.parse(localReferralData)
        
        // Th√™m c√°c tr∆∞·ªùng c√≤n thi·∫øu
        const fixedReferralData = {
          ...referralData,
          totalReferrals: referralData.totalReferrals || 0,
          totalEarnings: referralData.totalEarnings || 0,
          activeReferrals: referralData.activeReferrals || 0,
          conversionRate: referralData.conversionRate || 0,
          level: referralData.level || 'F0',
          refsNeeded: referralData.refsNeeded || 15,
          updatedAt: new Date()
        }
        
        localStorage.setItem('referralData', JSON.stringify(fixedReferralData))
        console.log('‚úÖ Referral data fixed in localStorage')
      }

      return { success: true }
    } catch (error) {
      console.error('‚ùå Referral data fix failed:', error)
      return { success: false, error: error.message }
    }
  }

  // T·∫°o b√°o c√°o
  generateReport() {
    const report = {
      timestamp: new Date().toISOString(),
      errors: this.errors,
      fixes: this.fixes,
      summary: {
        totalErrors: this.errors.length,
        totalFixes: this.fixes.length,
        status: this.errors.length === 0 ? 'healthy' : 'needs_attention'
      }
    }

    console.log('üìä Database Report:', report)
    return report
  }

  // Ch·∫°y full validation v√† fix
  async runFullCheck() {
    console.log('üöÄ Running full database check...')
    
    // Validate
    const validationResult = await this.validateDatabaseStructure()
    
    // Fix issues if validation failed
    if (!validationResult) {
      console.log('üîß Validation failed, attempting fixes...')
      await this.fixDatabaseIssues()
    }
    
    // Generate report
    const report = this.generateReport()
    
    return {
      validationResult,
      report
    }
  }
}

// Export singleton instance
export const databaseValidator = new DatabaseValidator()

// Auto-run validation on load
if (typeof window !== 'undefined') {
  window.addEventListener('DOMContentLoaded', () => {
    console.log('üîç Auto-running database validation...')
    databaseValidator.runFullCheck()
  })
}
